<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DrawKit: NSBezierPath(TextOnPath) Category Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DrawKit
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Vector and illustration framework for Mac OS X</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="#pub-static-methods">Class Methods</a> &#124;
<a href="category_n_s_bezier_path_07_text_on_path_08-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NSBezierPath(TextOnPath) Category Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#import &lt;<a class="el" href="_n_s_bezier_path_09_text_8h_source.html">NSBezierPath+Text.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:acdc605bce9b5b5b3754d2ef138aba84a"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#acdc605bce9b5b5b3754d2ef138aba84a">drawTextOnPath:yOffset:</a></td></tr>
<tr class="memdesc:acdc605bce9b5b5b3754d2ef138aba84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a string on a path.  <a href="#acdc605bce9b5b5b3754d2ef138aba84a">More...</a><br/></td></tr>
<tr class="separator:acdc605bce9b5b5b3754d2ef138aba84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954eec6f054eb6e81656176c64d1b988"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a954eec6f054eb6e81656176c64d1b988">drawStringOnPath:</a></td></tr>
<tr class="memdesc:a954eec6f054eb6e81656176c64d1b988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a string on a path.  <a href="#a954eec6f054eb6e81656176c64d1b988">More...</a><br/></td></tr>
<tr class="separator:a954eec6f054eb6e81656176c64d1b988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af617b320cb540fd6895e65f8c74d3c"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a4af617b320cb540fd6895e65f8c74d3c">drawStringOnPath:attributes:</a></td></tr>
<tr class="memdesc:a4af617b320cb540fd6895e65f8c74d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a string on a path.  <a href="#a4af617b320cb540fd6895e65f8c74d3c">More...</a><br/></td></tr>
<tr class="separator:a4af617b320cb540fd6895e65f8c74d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aeccfabcd59745f08d8e8381279d841"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a6aeccfabcd59745f08d8e8381279d841">drawTextOnPath:yOffset:layoutManager:cache:</a></td></tr>
<tr class="memdesc:a6aeccfabcd59745f08d8e8381279d841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a string on a path.  <a href="#a6aeccfabcd59745f08d8e8381279d841">More...</a><br/></td></tr>
<tr class="separator:a6aeccfabcd59745f08d8e8381279d841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab0b59bcc570ad14f5e8cd707367d13"><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a1ab0b59bcc570ad14f5e8cd707367d13">bezierPathsWithGlyphsOnPath:yOffset:</a></td></tr>
<tr class="memdesc:a1ab0b59bcc570ad14f5e8cd707367d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of paths each containing one glyph from the original text.  <a href="#a1ab0b59bcc570ad14f5e8cd707367d13">More...</a><br/></td></tr>
<tr class="separator:a1ab0b59bcc570ad14f5e8cd707367d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d3317dba19c41059e4257e465ba4bc"><td class="memItemLeft" align="right" valign="top">(NSBezierPath *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a88d3317dba19c41059e4257e465ba4bc">bezierPathWithTextOnPath:yOffset:</a></td></tr>
<tr class="memdesc:a88d3317dba19c41059e4257e465ba4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single path consisting of all of the laid out glyphs of the text.  <a href="#a88d3317dba19c41059e4257e465ba4bc">More...</a><br/></td></tr>
<tr class="separator:a88d3317dba19c41059e4257e465ba4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41123315b8016d4751d23b99e7e9e6d3"><td class="memItemLeft" align="right" valign="top">(NSBezierPath *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a41123315b8016d4751d23b99e7e9e6d3">bezierPathWithStringOnPath:</a></td></tr>
<tr class="memdesc:a41123315b8016d4751d23b99e7e9e6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single path consisting of all of the laid out glyphs of the text.  <a href="#a41123315b8016d4751d23b99e7e9e6d3">More...</a><br/></td></tr>
<tr class="separator:a41123315b8016d4751d23b99e7e9e6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca81d2935f012c091e6c2f0c9665fce"><td class="memItemLeft" align="right" valign="top">(NSBezierPath *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#afca81d2935f012c091e6c2f0c9665fce">bezierPathWithStringOnPath:attributes:</a></td></tr>
<tr class="memdesc:afca81d2935f012c091e6c2f0c9665fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single path consisting of all of the laid out glyphs of the text.  <a href="#afca81d2935f012c091e6c2f0c9665fce">More...</a><br/></td></tr>
<tr class="separator:afca81d2935f012c091e6c2f0c9665fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bae7bdec768bcef38e7821f3002b9d2"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a9bae7bdec768bcef38e7821f3002b9d2">layoutStringOnPath:yOffset:usingLayoutHelper:layoutManager:cache:</a></td></tr>
<tr class="memdesc:a9bae7bdec768bcef38e7821f3002b9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level method performs all text on path layout.  <a href="#a9bae7bdec768bcef38e7821f3002b9d2">More...</a><br/></td></tr>
<tr class="separator:a9bae7bdec768bcef38e7821f3002b9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c771f9b9b73017ad2dc087f96d59293"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a4c771f9b9b73017ad2dc087f96d59293">kernText:toFitLength:</a></td></tr>
<tr class="memdesc:a4c771f9b9b73017ad2dc087f96d59293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level method adjusts text to fit the path length.  <a href="#a4c771f9b9b73017ad2dc087f96d59293">More...</a><br/></td></tr>
<tr class="separator:a4c771f9b9b73017ad2dc087f96d59293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9e5a322ae6f32f4b5157170e7d6930"><td class="memItemLeft" align="right" valign="top">(NSTextStorage *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a1f9e5a322ae6f32f4b5157170e7d6930">preadjustedTextStorageWithString:layoutManager:</a></td></tr>
<tr class="memdesc:a1f9e5a322ae6f32f4b5157170e7d6930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level method adjusts justified text to fit the path length.  <a href="#a1f9e5a322ae6f32f4b5157170e7d6930">More...</a><br/></td></tr>
<tr class="separator:a1f9e5a322ae6f32f4b5157170e7d6930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00eab8b51a52d78b4284a8d8c9fa05ac"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a00eab8b51a52d78b4284a8d8c9fa05ac">drawUnderlinePathForLayoutManager:yOffset:cache:</a></td></tr>
<tr class="memdesc:a00eab8b51a52d78b4284a8d8c9fa05ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level method draws the underline attributes for the text if necessary.  <a href="#a00eab8b51a52d78b4284a8d8c9fa05ac">More...</a><br/></td></tr>
<tr class="separator:a00eab8b51a52d78b4284a8d8c9fa05ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af080afdb5d7f56e8e923fd25e8549a81"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#af080afdb5d7f56e8e923fd25e8549a81">drawStrikethroughPathForLayoutManager:yOffset:cache:</a></td></tr>
<tr class="memdesc:af080afdb5d7f56e8e923fd25e8549a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level method draws the strikethrough attributes for the text if necessary.  <a href="#af080afdb5d7f56e8e923fd25e8549a81">More...</a><br/></td></tr>
<tr class="separator:af080afdb5d7f56e8e923fd25e8549a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4d0945ee363c43a4f49b3cf8bd3be9"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a3b4d0945ee363c43a4f49b3cf8bd3be9">drawUnderlinePathForLayoutManager:range:yOffset:cache:</a></td></tr>
<tr class="memdesc:a3b4d0945ee363c43a4f49b3cf8bd3be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level method draws the undeline attributes for ranges of text.  <a href="#a3b4d0945ee363c43a4f49b3cf8bd3be9">More...</a><br/></td></tr>
<tr class="separator:a3b4d0945ee363c43a4f49b3cf8bd3be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036c3400fdc5c020bddc19a57c845cbf"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a036c3400fdc5c020bddc19a57c845cbf">drawStrikethroughPathForLayoutManager:range:yOffset:cache:</a></td></tr>
<tr class="memdesc:a036c3400fdc5c020bddc19a57c845cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level method draws the strikethrough attributes for ranges of text.  <a href="#a036c3400fdc5c020bddc19a57c845cbf">More...</a><br/></td></tr>
<tr class="separator:a036c3400fdc5c020bddc19a57c845cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cea1e05a9919cd5c0d181cdacadbe8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a84cea1e05a9919cd5c0d181cdacadbe8">pathPosition:andLength:forCharactersOfString:inRange:</a></td></tr>
<tr class="memdesc:a84cea1e05a9919cd5c0d181cdacadbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the start and end locations of ranges of text on the path.  <a href="#a84cea1e05a9919cd5c0d181cdacadbe8">More...</a><br/></td></tr>
<tr class="separator:a84cea1e05a9919cd5c0d181cdacadbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f6fd2e0fd4075dd5b914ba28594d5e"><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#ad2f6fd2e0fd4075dd5b914ba28594d5e">descenderBreaksForString:range:underlineOffset:</a></td></tr>
<tr class="memdesc:ad2f6fd2e0fd4075dd5b914ba28594d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the positions of any descender breaks for drawing underlines.  <a href="#ad2f6fd2e0fd4075dd5b914ba28594d5e">More...</a><br/></td></tr>
<tr class="separator:ad2f6fd2e0fd4075dd5b914ba28594d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28f5c9a98c7fef9d8b7c1be9c162224"><td class="memItemLeft" align="right" valign="top">(NSBezierPath *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#af28f5c9a98c7fef9d8b7c1be9c162224">textLinePathWithMask:startPosition:length:offset:lineThickness:descenderBreaks:grotThreshold:</a></td></tr>
<tr class="memdesc:af28f5c9a98c7fef9d8b7c1be9c162224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts all the information about an underline into a path that can be drawn.  <a href="#af28f5c9a98c7fef9d8b7c1be9c162224">More...</a><br/></td></tr>
<tr class="separator:af28f5c9a98c7fef9d8b7c1be9c162224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea318f927d8f08840c4ecbe74ea8c2f3"><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#aea318f927d8f08840c4ecbe74ea8c2f3">intersectingPointsWithHorizontalLineAtY:</a></td></tr>
<tr class="memdesc:aea318f927d8f08840c4ecbe74ea8c2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the points where a line drawn horizontally across the path will intersect it.  <a href="#aea318f927d8f08840c4ecbe74ea8c2f3">More...</a><br/></td></tr>
<tr class="separator:aea318f927d8f08840c4ecbe74ea8c2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4526d2ae5104cb94ef63782176734721"><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a4526d2ae5104cb94ef63782176734721">lineFragmentRectsForFixedLineheight:</a></td></tr>
<tr class="memdesc:a4526d2ae5104cb94ef63782176734721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find rectangles within which text can be laid out to place the text within the path.  <a href="#a4526d2ae5104cb94ef63782176734721">More...</a><br/></td></tr>
<tr class="separator:a4526d2ae5104cb94ef63782176734721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18b4e219a3d0055b3c63a35ad8f2599"><td class="memItemLeft" align="right" valign="top">(NSRect)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#ab18b4e219a3d0055b3c63a35ad8f2599">lineFragmentRectForProposedRect:remainingRect:</a></td></tr>
<tr class="memdesc:ab18b4e219a3d0055b3c63a35ad8f2599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a line fragement rectange for laying out text in this shape.  <a href="#ab18b4e219a3d0055b3c63a35ad8f2599">More...</a><br/></td></tr>
<tr class="separator:ab18b4e219a3d0055b3c63a35ad8f2599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe20668799d3389b1a838dc84ccdba0"><td class="memItemLeft" align="right" valign="top">(NSRect)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#aafe20668799d3389b1a838dc84ccdba0">lineFragmentRectForProposedRect:remainingRect:datumOffset:</a></td></tr>
<tr class="memdesc:aafe20668799d3389b1a838dc84ccdba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a line fragement rectange for laying out text in this shape.  <a href="#aafe20668799d3389b1a838dc84ccdba0">More...</a><br/></td></tr>
<tr class="separator:aafe20668799d3389b1a838dc84ccdba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4fcab2ce5110a6f15d61d56e7d1af7"><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a1d4fcab2ce5110a6f15d61d56e7d1af7">placeObjectsOnPathAtInterval:factoryObject:userInfo:</a></td></tr>
<tr class="memdesc:a1d4fcab2ce5110a6f15d61d56e7d1af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places objects at regular intervals along the path.  <a href="#a1d4fcab2ce5110a6f15d61d56e7d1af7">More...</a><br/></td></tr>
<tr class="separator:a1d4fcab2ce5110a6f15d61d56e7d1af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8769e2e5f94147a92e8c788923d479c0"><td class="memItemLeft" align="right" valign="top">(NSBezierPath *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a8769e2e5f94147a92e8c788923d479c0">bezierPathWithObjectsOnPathAtInterval:factoryObject:userInfo:</a></td></tr>
<tr class="memdesc:a8769e2e5f94147a92e8c788923d479c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places objects at regular intervals along the path.  <a href="#a8769e2e5f94147a92e8c788923d479c0">More...</a><br/></td></tr>
<tr class="separator:a8769e2e5f94147a92e8c788923d479c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7083205c614fb8683db57d628b444e5f"><td class="memItemLeft" align="right" valign="top">(NSBezierPath *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a7083205c614fb8683db57d628b444e5f">bezierPathWithPath:atInterval:</a></td></tr>
<tr class="memdesc:a7083205c614fb8683db57d628b444e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places copies of a given path at regular intervals along the path.  <a href="#a7083205c614fb8683db57d628b444e5f">More...</a><br/></td></tr>
<tr class="separator:a7083205c614fb8683db57d628b444e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bc2eae29979c75aafef1c4dd98816a"><td class="memItemLeft" align="right" valign="top">(NSBezierPath *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#ab0bc2eae29979c75aafef1c4dd98816a">bezierPathWithPath:atInterval:phase:alternate:taperDelegate:</a></td></tr>
<tr class="memdesc:ab0bc2eae29979c75aafef1c4dd98816a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places copies of a given path at regular intervals along the path.  <a href="#ab0bc2eae29979c75aafef1c4dd98816a">More...</a><br/></td></tr>
<tr class="separator:ab0bc2eae29979c75aafef1c4dd98816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0388373faf9e55fa91d1f5a432268f"><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a2e0388373faf9e55fa91d1f5a432268f">placeLinksOnPathWithLinkLength:factoryObject:userInfo:</a></td></tr>
<tr class="memdesc:a2e0388373faf9e55fa91d1f5a432268f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places "links" along the path at equal intervals.  <a href="#a2e0388373faf9e55fa91d1f5a432268f">More...</a><br/></td></tr>
<tr class="separator:a2e0388373faf9e55fa91d1f5a432268f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe3d6060ae4ca86d71c65c72cac359b"><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a1fe3d6060ae4ca86d71c65c72cac359b">placeLinksOnPathWithEvenLinkLength:oddLinkLength:factoryObject:userInfo:</a></td></tr>
<tr class="memdesc:a1fe3d6060ae4ca86d71c65c72cac359b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places "links" along the path at alternating even and odd intervals.  <a href="#a1fe3d6060ae4ca86d71c65c72cac359b">More...</a><br/></td></tr>
<tr class="separator:a1fe3d6060ae4ca86d71c65c72cac359b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b04eddd4e23df3a14a29583ce9db03b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a5b04eddd4e23df3a14a29583ce9db03b">moveObject:atSpeed:loop:userInfo:</a></td></tr>
<tr class="memdesc:a5b04eddd4e23df3a14a29583ce9db03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves an object along the path at a constant speed.  <a href="#a5b04eddd4e23df3a14a29583ce9db03b">More...</a><br/></td></tr>
<tr class="separator:a5b04eddd4e23df3a14a29583ce9db03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Class Methods</h2></td></tr>
<tr class="memitem:a05b5721c750a685f39e204228b587cec"><td class="memItemLeft" align="right" valign="top">(NSLayoutManager *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a05b5721c750a685f39e204228b587cec">textOnPathLayoutManager</a></td></tr>
<tr class="memdesc:a05b5721c750a685f39e204228b587cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a layout manager used for text on path layout.  <a href="#a05b5721c750a685f39e204228b587cec">More...</a><br/></td></tr>
<tr class="separator:a05b5721c750a685f39e204228b587cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76790c288d86f418a2c08388cb43bd1c"><td class="memItemLeft" align="right" valign="top">(NSDictionary *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a76790c288d86f418a2c08388cb43bd1c">textOnPathDefaultAttributes</a></td></tr>
<tr class="memdesc:a76790c288d86f418a2c08388cb43bd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the attributes used to draw strings on paths.  <a href="#a76790c288d86f418a2c08388cb43bd1c">More...</a><br/></td></tr>
<tr class="separator:a76790c288d86f418a2c08388cb43bd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41cafb69529562579d05c961ddca882"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#ae41cafb69529562579d05c961ddca882">setTextOnPathDefaultAttributes:</a></td></tr>
<tr class="memdesc:ae41cafb69529562579d05c961ddca882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the attributes used to draw strings on paths.  <a href="#ae41cafb69529562579d05c961ddca882">More...</a><br/></td></tr>
<tr class="separator:ae41cafb69529562579d05c961ddca882"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Graham Cox, Apptree.net </dd>
<dd>
Graham Miln, miln.eu </dd>
<dd>
Contributions from the community </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2005-2014 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>This software is released subject to licensing conditions as detailed in DRAWKIT-LICENSING.TXT, which must accompany this source file. </dd></dl>
</div><h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="a1ab0b59bcc570ad14f5e8cd707367d13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) bezierPathsWithGlyphsOnPath: </td>
          <td></td>
          <td class="paramtype">(NSAttributedString*)&#160;</td>
          <td class="paramname"><em>str</em></td>
        </tr>
        <tr>
          <td class="paramkey">yOffset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of paths each containing one glyph from the original text. </p>
<p>Each glyph is returned as a separate path, allowing attributes to be applied if required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to render </td></tr>
    <tr><td class="paramname">dy</td><td>the baseline offset between the path and the text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of bezier path objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a8769e2e5f94147a92e8c788923d479c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSBezierPath *) bezierPathWithObjectsOnPathAtInterval: </td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>interval</em></td>
        </tr>
        <tr>
          <td class="paramkey">factoryObject:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>object</em></td>
        </tr>
        <tr>
          <td class="paramkey">userInfo:</td>
          <td></td>
          <td class="paramtype">(void*)&#160;</td>
          <td class="paramname"><em>userInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places objects at regular intervals along the path. </p>
<p>The factory object creates a path at each position and it is added to the resulting path </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>the distance between each object placed </td></tr>
    <tr><td class="paramname">object</td><td>a factory object used to supply the paths placed </td></tr>
    <tr><td class="paramname">userInfo</td><td>information passed to the factory object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single path consisting of all of the added paths </dd></dl>

</div>
</div>
<a class="anchor" id="a7083205c614fb8683db57d628b444e5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSBezierPath *) bezierPathWithPath: </td>
          <td></td>
          <td class="paramtype">(NSBezierPath*)&#160;</td>
          <td class="paramname"><em>path</em></td>
        </tr>
        <tr>
          <td class="paramkey">atInterval:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places copies of a given path at regular intervals along the path. </p>
<p>The origin of &lt;path&gt; is positioned on the receiver's path at the designated location. The caller should ensure that the origin is sensible - paths based on 0,0 work as expected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>a path to position at intervals on this path </td></tr>
    <tr><td class="paramname">interval</td><td>the distance between each object placed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single path consisting of all of the added paths </dd></dl>

</div>
</div>
<a class="anchor" id="ab0bc2eae29979c75aafef1c4dd98816a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSBezierPath *) bezierPathWithPath: </td>
          <td></td>
          <td class="paramtype">(NSBezierPath*)&#160;</td>
          <td class="paramname"><em>path</em></td>
        </tr>
        <tr>
          <td class="paramkey">atInterval:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>interval</em></td>
        </tr>
        <tr>
          <td class="paramkey">phase:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>phase</em></td>
        </tr>
        <tr>
          <td class="paramkey">alternate:</td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>alt</em></td>
        </tr>
        <tr>
          <td class="paramkey">taperDelegate:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>taperDel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places copies of a given path at regular intervals along the path. </p>
<p>The origin of &lt;path&gt; is positioned on the receiver's path at the designated location. The caller should ensure that the origin is sensible - paths based on 0,0 work as expected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>a path to position at intervals on this path </td></tr>
    <tr><td class="paramname">interval</td><td>the distance between each object placed </td></tr>
    <tr><td class="paramname">phase</td><td>an initial offset added to the distance </td></tr>
    <tr><td class="paramname">alternate</td><td>if YES, odd-numbered elements are reversed 180 degrees </td></tr>
    <tr><td class="paramname">taperDel</td><td>an optional taper delegate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single path consisting of all of the added paths </dd></dl>

</div>
</div>
<a class="anchor" id="a41123315b8016d4751d23b99e7e9e6d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSBezierPath *) bezierPathWithStringOnPath: </td>
          <td></td>
          <td class="paramtype">(NSString*)&#160;</td>
          <td class="paramname"><em>str</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a single path consisting of all of the laid out glyphs of the text. </p>
<p>The string is drawn using the class attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to render </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of bezier path objects. </dd></dl>

</div>
</div>
<a class="anchor" id="afca81d2935f012c091e6c2f0c9665fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSBezierPath *) <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a41123315b8016d4751d23b99e7e9e6d3">bezierPathWithStringOnPath:</a> </td>
          <td></td>
          <td class="paramtype">(NSString*)&#160;</td>
          <td class="paramname"><em>str</em></td>
        </tr>
        <tr>
          <td class="paramkey">attributes:</td>
          <td></td>
          <td class="paramtype">(NSDictionary*)&#160;</td>
          <td class="paramname"><em>attrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a single path consisting of all of the laid out glyphs of the text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to render </td></tr>
    <tr><td class="paramname">attrs</td><td>the drawing attributes for the text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of bezier path objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a88d3317dba19c41059e4257e465ba4bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSBezierPath *) bezierPathWithTextOnPath: </td>
          <td></td>
          <td class="paramtype">(NSAttributedString*)&#160;</td>
          <td class="paramname"><em>str</em></td>
        </tr>
        <tr>
          <td class="paramkey">yOffset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a single path consisting of all of the laid out glyphs of the text. </p>
<p>All glyph paths are added to the single bezier path. This preserves their original shapes but attribute information such as colour runs, etc are effectively lost. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to render </td></tr>
    <tr><td class="paramname">dy</td><td>the baseline offset between the path and the text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a single bezier path. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2f6fd2e0fd4075dd5b914ba28594d5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) descenderBreaksForString: </td>
          <td></td>
          <td class="paramtype">(NSAttributedString*)&#160;</td>
          <td class="paramname"><em>str</em></td>
        </tr>
        <tr>
          <td class="paramkey">range:</td>
          <td></td>
          <td class="paramtype">(NSRange)&#160;</td>
          <td class="paramname"><em>range</em></td>
        </tr>
        <tr>
          <td class="paramkey">underlineOffset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the positions of any descender breaks for drawing underlines. </p>
<p>In order to correctly and accurately interrupt an underline where a glyph descender 'cuts' through it, the locations of the start and end of each break must be computed. This does that by finding the intersections of the glyph paths and a notional underline path. As such it is computationally expensive (but is cached at a higher level). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string in question </td></tr>
    <tr><td class="paramname">range</td><td>the range of characters of interest within the string </td></tr>
    <tr><td class="paramname">offset</td><td>the distance between the text baseline and the underline </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of descender break positions (NSValues with NSPoint values) </dd></dl>

</div>
</div>
<a class="anchor" id="a036c3400fdc5c020bddc19a57c845cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) drawStrikethroughPathForLayoutManager: </td>
          <td></td>
          <td class="paramtype">(NSLayoutManager*)&#160;</td>
          <td class="paramname"><em>lm</em></td>
        </tr>
        <tr>
          <td class="paramkey">range:</td>
          <td></td>
          <td class="paramtype">(NSRange)&#160;</td>
          <td class="paramname"><em>range</em></td>
        </tr>
        <tr>
          <td class="paramkey">yOffset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>dy</em></td>
        </tr>
        <tr>
          <td class="paramkey">cache:</td>
          <td></td>
          <td class="paramtype">(NSMutableDictionary*)&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level method draws the strikethrough attributes for ranges of text. </p>
<p>Here be more dragons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lm</td><td>the layout manager in use </td></tr>
    <tr><td class="paramname">range</td><td>the range of text to apply the underline attribute to </td></tr>
    <tr><td class="paramname">dy</td><td>the text baseline offset from the path </td></tr>
    <tr><td class="paramname">cache</td><td>a cache used to store intermediate calculations to speed up repeated drawing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

</div>
</div>
<a class="anchor" id="af080afdb5d7f56e8e923fd25e8549a81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) drawStrikethroughPathForLayoutManager: </td>
          <td></td>
          <td class="paramtype">(NSLayoutManager*)&#160;</td>
          <td class="paramname"><em>lm</em></td>
        </tr>
        <tr>
          <td class="paramkey">yOffset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>dy</em></td>
        </tr>
        <tr>
          <td class="paramkey">cache:</td>
          <td></td>
          <td class="paramtype">(NSMutableDictionary*)&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level method draws the strikethrough attributes for the text if necessary. </p>
<p>Strikethrough text on a path is involved, as it needs to bypass NSLayoutManager's normal processing and handle it directly, in order to get smooth unbroken lines. While this sometimes results in strikethrough that differs from standard, it is very close and visually far nicer than leaving it to NSLayoutManager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lm</td><td>the layout manager in use </td></tr>
    <tr><td class="paramname">dy</td><td>the text baseline offset from the path </td></tr>
    <tr><td class="paramname">cache</td><td>a cache used to store intermediate calculations to speed up repeated drawing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

</div>
</div>
<a class="anchor" id="a954eec6f054eb6e81656176c64d1b988"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) drawStringOnPath: </td>
          <td></td>
          <td class="paramtype">(NSString*)&#160;</td>
          <td class="paramname"><em>str</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a string on a path. </p>
<p>Very high-level, draws the string on the path using the set class attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to render </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>YES if the text was fully laid out, NO if some text could not be drawn (for example because it would not all fit on the path). </dd></dl>

</div>
</div>
<a class="anchor" id="a4af617b320cb540fd6895e65f8c74d3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) <a class="el" href="category_n_s_bezier_path_07_text_on_path_08.html#a954eec6f054eb6e81656176c64d1b988">drawStringOnPath:</a> </td>
          <td></td>
          <td class="paramtype">(NSString*)&#160;</td>
          <td class="paramname"><em>str</em></td>
        </tr>
        <tr>
          <td class="paramkey">attributes:</td>
          <td></td>
          <td class="paramtype">(NSDictionary*)&#160;</td>
          <td class="paramname"><em>attrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a string on a path. </p>
<p>If attrs is nil, uses the current class attributes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to render </td></tr>
    <tr><td class="paramname">attrs</td><td>the attributes to use to draw the string - may be nil </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>YES if the text was fully laid out, NO if some text could not be drawn (for example because it would not all fit on the path). </dd></dl>

</div>
</div>
<a class="anchor" id="acdc605bce9b5b5b3754d2ef138aba84a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) drawTextOnPath: </td>
          <td></td>
          <td class="paramtype">(NSAttributedString*)&#160;</td>
          <td class="paramname"><em>str</em></td>
        </tr>
        <tr>
          <td class="paramkey">yOffset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a string on a path. </p>
<p>Positive values of dy place the text's baseline above the path, negative below it, where 'above' and 'below' are in the expected sense relative to the orientation of the drawn glyphs. This is the highest-level attributed text on path drawing method, and uses the shared layout mamanger and no cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the attributed string to render </td></tr>
    <tr><td class="paramname">dy</td><td>the offset between the path and the text's baseline when drawn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>YES if the text was fully laid out, NO if some text could not be drawn (for example because it would not all fit on the path). </dd></dl>

</div>
</div>
<a class="anchor" id="a6aeccfabcd59745f08d8e8381279d841"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) drawTextOnPath: </td>
          <td></td>
          <td class="paramtype">(NSAttributedString*)&#160;</td>
          <td class="paramname"><em>str</em></td>
        </tr>
        <tr>
          <td class="paramkey">yOffset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>dy</em></td>
        </tr>
        <tr>
          <td class="paramkey">layoutManager:</td>
          <td></td>
          <td class="paramtype">(NSLayoutManager*)&#160;</td>
          <td class="paramname"><em>lm</em></td>
        </tr>
        <tr>
          <td class="paramkey">cache:</td>
          <td></td>
          <td class="paramtype">(NSMutableDictionary*)&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a string on a path. </p>
<p>Passing nil for the layout manager uses the shared layout manager. If the same cache is passed back each time by the client code, certain calculations are cached there which can speed up drawing. The client owns the cache and is responsible for invalidating it (setting it empty) when text content changes. However the client code doesn't need to consider path changes - they are handled automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the attributed string to render </td></tr>
    <tr><td class="paramname">dy</td><td>the offset between the path and the text's baseline when drawn. </td></tr>
    <tr><td class="paramname">lm</td><td>the layout manager to use for layout </td></tr>
    <tr><td class="paramname">cache</td><td>an optional cache dictionary (must be a valid mutable dictionary, or nil) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>YES if the text was fully laid out, NO if some text could not be drawn (for example because it would not all fit on the path). </dd></dl>

</div>
</div>
<a class="anchor" id="a3b4d0945ee363c43a4f49b3cf8bd3be9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) drawUnderlinePathForLayoutManager: </td>
          <td></td>
          <td class="paramtype">(NSLayoutManager*)&#160;</td>
          <td class="paramname"><em>lm</em></td>
        </tr>
        <tr>
          <td class="paramkey">range:</td>
          <td></td>
          <td class="paramtype">(NSRange)&#160;</td>
          <td class="paramname"><em>range</em></td>
        </tr>
        <tr>
          <td class="paramkey">yOffset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>dy</em></td>
        </tr>
        <tr>
          <td class="paramkey">cache:</td>
          <td></td>
          <td class="paramtype">(NSMutableDictionary*)&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level method draws the undeline attributes for ranges of text. </p>
<p>Here be dragons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lm</td><td>the layout manager in use </td></tr>
    <tr><td class="paramname">range</td><td>the range of text to apply the underline attribute to </td></tr>
    <tr><td class="paramname">dy</td><td>the text baseline offset from the path </td></tr>
    <tr><td class="paramname">cache</td><td>a cache used to store intermediate calculations to speed up repeated drawing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

</div>
</div>
<a class="anchor" id="a00eab8b51a52d78b4284a8d8c9fa05ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) drawUnderlinePathForLayoutManager: </td>
          <td></td>
          <td class="paramtype">(NSLayoutManager*)&#160;</td>
          <td class="paramname"><em>lm</em></td>
        </tr>
        <tr>
          <td class="paramkey">yOffset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>dy</em></td>
        </tr>
        <tr>
          <td class="paramkey">cache:</td>
          <td></td>
          <td class="paramtype">(NSMutableDictionary*)&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level method draws the underline attributes for the text if necessary. </p>
<p>Underlining text on a path is very involved, as it needs to bypass NSLayoutManager's normal underline processing and handle it directly, in order to get smooth unbroken lines. While this sometimes results in underlining that differs from standard, it is very close and visually far nicer than leaving it to NSLayoutManager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lm</td><td>the layout manager in use </td></tr>
    <tr><td class="paramname">dy</td><td>the text baseline offset from the path </td></tr>
    <tr><td class="paramname">cache</td><td>a cache used to store intermediate calculations to speed up repeated drawing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

</div>
</div>
<a class="anchor" id="aea318f927d8f08840c4ecbe74ea8c2f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) intersectingPointsWithHorizontalLineAtY: </td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>yPosition</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the points where a line drawn horizontally across the path will intersect it. </p>
<p>This works by approximating the curve as a series of straight lines and testing each one for intersection with the line at y. This is the primitive method used to determine line layout rectangles - a series of calls to this is needed for each line (incrementing y by the lineheight) and then rects forming from the resulting points. See -lineFragmentRectsForFixedLineheight: This is also used when calculating descender breaks for underlining text on a path. This method is guaranteed to return an even number of (or none) results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yPosition</td><td>the distance between the top edge of the bounds and the line to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of NSValues containing NSPoints </dd></dl>

</div>
</div>
<a class="anchor" id="a4c771f9b9b73017ad2dc087f96d59293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) kernText: </td>
          <td></td>
          <td class="paramtype">(NSTextStorage*)&#160;</td>
          <td class="paramname"><em>text</em></td>
        </tr>
        <tr>
          <td class="paramkey">toFitLength:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level method adjusts text to fit the path length. </p>
<p>Modifies the text storage in place by setting NSKernAttribute to stretch or compress the text to fit the given length. Text is only compressed by a certain amount - beyond that characters are dropped from the end of the line when laid out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text storage containing the text to lay out </td></tr>
    <tr><td class="paramname">length</td><td>the path length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bae7bdec768bcef38e7821f3002b9d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) layoutStringOnPath: </td>
          <td></td>
          <td class="paramtype">(NSTextStorage*)&#160;</td>
          <td class="paramname"><em>str</em></td>
        </tr>
        <tr>
          <td class="paramkey">yOffset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>dy</em></td>
        </tr>
        <tr>
          <td class="paramkey">usingLayoutHelper:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>helperObject</em></td>
        </tr>
        <tr>
          <td class="paramkey">layoutManager:</td>
          <td></td>
          <td class="paramtype">(NSLayoutManager*)&#160;</td>
          <td class="paramname"><em>lm</em></td>
        </tr>
        <tr>
          <td class="paramkey">cache:</td>
          <td></td>
          <td class="paramtype">(NSMutableDictionary*)&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level method performs all text on path layout. </p>
<p>This method does all the actual work of glyph generation and positioning of the glyphs along the path. It is called by all other methods. The helper object does the appropriate thing, either adding the glyph outline to a list or actually drawing the glyph. Note that the glyph layout is handled by the layout manager as usual, but the helper is responsible for the last step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the attributed string to render </td></tr>
    <tr><td class="paramname">dy</td><td>the text baseline offset </td></tr>
    <tr><td class="paramname">helperObject</td><td>a helper object used to process each glyph as it is laid out </td></tr>
    <tr><td class="paramname">lm</td><td>the layout manager that performs the layout </td></tr>
    <tr><td class="paramname">cache</td><td>a cache used to save layout informaiton to avoid recalculation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>YES if all text was laid out, NO if some text was not laid out. </dd></dl>

</div>
</div>
<a class="anchor" id="ab18b4e219a3d0055b3c63a35ad8f2599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSRect) lineFragmentRectForProposedRect: </td>
          <td></td>
          <td class="paramtype">(NSRect)&#160;</td>
          <td class="paramname"><em>aRect</em></td>
        </tr>
        <tr>
          <td class="paramkey">remainingRect:</td>
          <td></td>
          <td class="paramtype">(NSRect*)&#160;</td>
          <td class="paramname"><em>rem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a line fragement rectange for laying out text in this shape. </p>
<p>See -lineFragmentRectForProposedRect:remainingRect:datumOffset: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aRect</td><td>the proposed rectangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the available rectangle for the text given the proposed rect </dd></dl>

</div>
</div>
<a class="anchor" id="aafe20668799d3389b1a838dc84ccdba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSRect) lineFragmentRectForProposedRect: </td>
          <td></td>
          <td class="paramtype">(NSRect)&#160;</td>
          <td class="paramname"><em>aRect</em></td>
        </tr>
        <tr>
          <td class="paramkey">remainingRect:</td>
          <td></td>
          <td class="paramtype">(NSRect*)&#160;</td>
          <td class="paramname"><em>rem</em></td>
        </tr>
        <tr>
          <td class="paramkey">datumOffset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>dOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a line fragement rectange for laying out text in this shape. </p>
<p>This offsets &lt;proposedRect&gt; to the right to the next even-numbered intersection point, setting its length to the difference between that point and the next. That part is the return value. If there are any further points, the remainder is set to the rest of the rect. This allows this method to be used directly by a NSTextContainer subclass (see <a class="el" href="interface_d_k_bezier_text_container.html" title="This class is used by DKTextAdornment to lay out text flowed into an arbitrary shape. ">DKBezierTextContainer</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aRect</td><td>the proposed rectangle </td></tr>
    <tr><td class="paramname">dOffset</td><td>a value between +0.5 and -0.5 that represents the relative position within the line used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the available rectangle for the text given the proposed rect </dd></dl>

</div>
</div>
<a class="anchor" id="a4526d2ae5104cb94ef63782176734721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) lineFragmentRectsForFixedLineheight: </td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>lineHeight</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find rectangles within which text can be laid out to place the text within the path. </p>
<p>Given a lineheight value, this returns an array of rects (as NSValues) which are the ordered line layout rects from left to right and top to bottom within the shape to layout text in. This is computationally intensive, so the result should probably be cached until the shape is actually changed. This works with a fixed lineheight, where every line is the same. Note that this method isn't really suitable for use with NSTextContainer or Cocoa's text system in general - for flowing text using NSLayoutManager use <a class="el" href="interface_d_k_bezier_text_container.html" title="This class is used by DKTextAdornment to lay out text flowed into an arbitrary shape. ">DKBezierTextContainer</a> which calls the -lineFragmentRectForProposedRect:remainingRect: method below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lineHeight</td><td>the lineheight for the lines of text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of NSValues containing NSRects </dd></dl>

</div>
</div>
<a class="anchor" id="a5b04eddd4e23df3a14a29583ce9db03b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) moveObject: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>object</em></td>
        </tr>
        <tr>
          <td class="paramkey">atSpeed:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>speed</em></td>
        </tr>
        <tr>
          <td class="paramkey">loop:</td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>loop</em></td>
        </tr>
        <tr>
          <td class="paramkey">userInfo:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>userInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves an object along the path at a constant speed. </p>
<p>The object must respond to the informal motion protocol. This method starts a timer which runs until either the end of the path is reached when loop is NO, or until the object being moved itself returns NO. The timer runs at 30 fps and the distance moved is calculated accordingly - this gives accurate motion speed regardless of framerate, and will drop frames if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>the object to be moved (i.e. animated) </td></tr>
    <tr><td class="paramname">speed</td><td>the linear motion speed in points per second </td></tr>
    <tr><td class="paramname">loop</td><td>YES to repeatedly loop the movement when it gets to the end, NO for one-time motion. </td></tr>
    <tr><td class="paramname">userInfo</td><td>user info passed to the object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84cea1e05a9919cd5c0d181cdacadbe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) pathPosition: </td>
          <td></td>
          <td class="paramtype">(CGFloat*)&#160;</td>
          <td class="paramname"><em>start</em></td>
        </tr>
        <tr>
          <td class="paramkey">andLength:</td>
          <td></td>
          <td class="paramtype">(CGFloat*)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">forCharactersOfString:</td>
          <td></td>
          <td class="paramtype">(NSAttributedString*)&#160;</td>
          <td class="paramname"><em>str</em></td>
        </tr>
        <tr>
          <td class="paramkey">inRange:</td>
          <td></td>
          <td class="paramtype">(NSRange)&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the start and end locations of ranges of text on the path. </p>
<p>Used to compute start positions and length of runs of attributes along the path, such as underlines and strikethroughs. Paragraph styles affect this, so the results tell you where to draw. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>receives the starting position of the range of characters </td></tr>
    <tr><td class="paramname">length</td><td>receives the length of the range of characters </td></tr>
    <tr><td class="paramname">str</td><td>the string in question </td></tr>
    <tr><td class="paramname">range</td><td>the range of characters of interest within the string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1fe3d6060ae4ca86d71c65c72cac359b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) placeLinksOnPathWithEvenLinkLength: </td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>ell</em></td>
        </tr>
        <tr>
          <td class="paramkey">oddLinkLength:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>oll</em></td>
        </tr>
        <tr>
          <td class="paramkey">factoryObject:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>object</em></td>
        </tr>
        <tr>
          <td class="paramkey">userInfo:</td>
          <td></td>
          <td class="paramtype">(void*)&#160;</td>
          <td class="paramname"><em>userInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places "links" along the path at alternating even and odd intervals. </p>
<p>Similar to object placement, but treats the objects as "links" like in a chain, where a rigid link of a fixed length connects two points on the path. The factory object is called with the pair of points computed, and returns a path representing the link between those two points. Non-nil results are accumulated into the array returned. Even and odd links can have different lengths for added flexibility. Note that to keep this working quickly, the link length is used as a path length to find the initial link pivot point, then the actual point is calculated by using the link radius in this direction. The result can be that links will not exactly follow a very convoluted or curved path, but each link is guaranteed to be a fixed length and exactly join to its neighbours. In practice, this gives results that are very "physical" in that it emulates the behaviour of real chains that are bent through acute angles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ell</td><td>the even interval </td></tr>
    <tr><td class="paramname">oll</td><td>th eodd interval </td></tr>
    <tr><td class="paramname">object</td><td>a factory object used to generate the links themselves </td></tr>
    <tr><td class="paramname">userInfo</td><td>user info passed to the factory object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of created link objects </dd></dl>

</div>
</div>
<a class="anchor" id="a2e0388373faf9e55fa91d1f5a432268f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) placeLinksOnPathWithLinkLength: </td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>ll</em></td>
        </tr>
        <tr>
          <td class="paramkey">factoryObject:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>object</em></td>
        </tr>
        <tr>
          <td class="paramkey">userInfo:</td>
          <td></td>
          <td class="paramtype">(void*)&#160;</td>
          <td class="paramname"><em>userInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places "links" along the path at equal intervals. </p>
<p>See notes for placeLinksOnPathWithEvenLinkLength:oddLinkLength:factoryObject:userInfo: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>the interval and length of each "link" </td></tr>
    <tr><td class="paramname">object</td><td>a factory object used to generate the links themselves </td></tr>
    <tr><td class="paramname">userInfo</td><td>user info passed to the factory object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of created link objects </dd></dl>

</div>
</div>
<a class="anchor" id="a1d4fcab2ce5110a6f15d61d56e7d1af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) placeObjectsOnPathAtInterval: </td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>interval</em></td>
        </tr>
        <tr>
          <td class="paramkey">factoryObject:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>object</em></td>
        </tr>
        <tr>
          <td class="paramkey">userInfo:</td>
          <td></td>
          <td class="paramtype">(void*)&#160;</td>
          <td class="paramname"><em>userInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places objects at regular intervals along the path. </p>
<p>The factory object creates an object at each position and it is added to the result array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>the distance between each object placed </td></tr>
    <tr><td class="paramname">object</td><td>a factory object used to supply the paths placed </td></tr>
    <tr><td class="paramname">userInfo</td><td>information passed to the factory object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of placed objects </dd></dl>

</div>
</div>
<a class="anchor" id="a1f9e5a322ae6f32f4b5157170e7d6930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSTextStorage *) preadjustedTextStorageWithString: </td>
          <td></td>
          <td class="paramtype">(NSAttributedString*)&#160;</td>
          <td class="paramname"><em>str</em></td>
        </tr>
        <tr>
          <td class="paramkey">layoutManager:</td>
          <td></td>
          <td class="paramtype">(NSLayoutManager*)&#160;</td>
          <td class="paramname"><em>lm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level method adjusts justified text to fit the path length. </p>
<p>This does two things - it sets up the text's container so that text will be laid out properly within the path's length, and secondly if the text is "justified" it kerns the text to fit the path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text storage containing the text to lay out </td></tr>
    <tr><td class="paramname">length</td><td>the path length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

</div>
</div>
<a class="anchor" id="ae41cafb69529562579d05c961ddca882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) setTextOnPathDefaultAttributes: </td>
          <td></td>
          <td class="paramtype">(NSDictionary*)&#160;</td>
          <td class="paramname"><em>attrs</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the attributes used to draw strings on paths. </p>
<p>Pass nil to set the default. The attributes are used by the drawStringOnPath: method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>a dictionary of text attributes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af28f5c9a98c7fef9d8b7c1be9c162224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSBezierPath *) textLinePathWithMask: </td>
          <td></td>
          <td class="paramtype">(NSInteger)&#160;</td>
          <td class="paramname"><em>mask</em></td>
        </tr>
        <tr>
          <td class="paramkey">startPosition:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>sp</em></td>
        </tr>
        <tr>
          <td class="paramkey">length:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>length</em></td>
        </tr>
        <tr>
          <td class="paramkey">offset:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">lineThickness:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>lineThickness</em></td>
        </tr>
        <tr>
          <td class="paramkey">descenderBreaks:</td>
          <td></td>
          <td class="paramtype">(NSArray*)&#160;</td>
          <td class="paramname"><em>breaks</em></td>
        </tr>
        <tr>
          <td class="paramkey">grotThreshold:</td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>gt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts all the information about an underline into a path that can be drawn. </p>
<p>Where descender breaks are passed in, the gap on either side of the break is widened by a factor based on gt, which in turn is usually derived from the text size. This allows the breaks to size proportionally to give pleasing results. The result may differ from Apple's standard text block rendition (but note that for some fonts, DK's way works where Apple's does not, e.g. Zapfino) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>the underline attributes mask value </td></tr>
    <tr><td class="paramname">sp</td><td>the starting position for the underline on the path </td></tr>
    <tr><td class="paramname">length</td><td>the length of the underline on the path </td></tr>
    <tr><td class="paramname">offset</td><td>the distance between the text baseline and the underline </td></tr>
    <tr><td class="paramname">lineThickness</td><td>the thickness of the underline </td></tr>
    <tr><td class="paramname">breaks</td><td>an array of descender breakpoints, or nil </td></tr>
    <tr><td class="paramname">gt</td><td>threshold value to suppress inclusion of very short "bits" of underline (a.k.a "grot") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A path. Stroking this path draws the underline. </dd></dl>

</div>
</div>
<a class="anchor" id="a76790c288d86f418a2c08388cb43bd1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSDictionary *) textOnPathDefaultAttributes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the attributes used to draw strings on paths. </p>
<p>The default is 12 point Helvetica Roman black text with the default paragraph style. </p>
<dl class="section return"><dt>Returns</dt><dd>a dictionary of string attributes </dd></dl>

</div>
</div>
<a class="anchor" id="a05b5721c750a685f39e204228b587cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSLayoutManager *) textOnPathLayoutManager </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a layout manager used for text on path layout. </p>
<p>This shared layout manager is used by text on path drawing unless a specific manager is passed. </p>
<dl class="section return"><dt>Returns</dt><dd>a shared layout manager instance </dd></dl>

</div>
</div>
<hr/>The documentation for this category was generated from the following files:<ul>
<li><a class="el" href="_n_s_bezier_path_09_text_8h_source.html">NSBezierPath+Text.h</a></li>
<li>NSBezierPath+Text.m</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
